{"output":{"questions":[{"type":"multichoice","question":"¿Cuál es el acrónimo completo y el significado de \"Bash\"?","options":[{"text":"Bourne-Again SHell","is_correct":true,"feedback":"Correcto. Bash significa 'Bourne-Again SHell', un juego de palabras con Stephen Bourne, el autor del shell original de Unix."},{"text":"Bell-Again SHell","is_correct":false,"feedback":"Incorrecto. El nombre no está relacionado con Bell Labs de esa manera."},{"text":"Basic SHell","is_correct":false,"feedback":"Incorrecto. Aunque es un shell básico, el nombre es un acrónimo específico."},{"text":"Bourne SHell","is_correct":false,"feedback":"Incorrecto. Bash es una evolución del Bourne Shell, pero no es el mismo."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has identificado correctamente el origen del nombre de Bash.","feedback_incorrect":"Incorrecto. Repasa la sección de Introducción para entender el significado del nombre de Bash."},{"type":"multichoice","question":"¿Cuál es la función fundamental de un shell en su base, según el manual?","options":[{"text":"Un macroprocesador que ejecuta comandos.","is_correct":true,"feedback":"Correcto. El manual establece que un shell es fundamentalmente un macroprocesador."},{"text":"Un gestor de archivos del sistema operativo.","is_correct":false,"feedback":"Incorrecto. Aunque los shells interactúan con archivos, su función fundamental es otra."},{"text":"Un editor de texto avanzado.","is_correct":false,"feedback":"Incorrecto. Los shells no son editores de texto."},{"text":"Un compilador de programas.","is_correct":false,"feedback":"Incorrecto. Los shells son intérpretes, no compiladores."}],"correct_answer":true,"feedback_correct":"¡Exacto! Un shell es esencialmente un macroprocesador de comandos.","feedback_incorrect":"Incorrecto. Revisa la definición básica de un shell en la Introducción."},{"type":"multichoice","question":"¿Cómo se diferencian los shells al ejecutarse en modo interactivo y no interactivo?","options":[{"text":"En modo interactivo aceptan entrada desde el teclado; en modo no interactivo, ejecutan comandos leídos de un archivo o cadena.","is_correct":true,"feedback":"Correcto. Esta es la distinción clave entre los modos interactivo y no interactivo."},{"text":"En modo interactivo ejecutan comandos en segundo plano; en modo no interactivo, esperan a que se completen.","is_correct":false,"feedback":"Incorrecto. Esto se refiere a la ejecución síncrona/asíncrona, no a la interactividad del shell."},{"text":"En modo interactivo usan un lenguaje de programación; en modo no interactivo solo ejecutan comandos simples.","is_correct":false,"feedback":"Incorrecto. Los shells utilizan características de lenguaje de programación en ambos modos."},{"text":"Los shells no distinguen entre modos interactivos y no interactivos.","is_correct":false,"feedback":"Incorrecto. El manual explica claramente la diferencia entre estos dos modos."}],"correct_answer":true,"feedback_correct":"¡Muy bien! Has entendido la diferencia entre los modos interactivo y no interactivo.","feedback_incorrect":"Incorrecto. Repasa la sección de Introducción para aclarar las diferencias entre los modos de operación del shell."},{"type":"multichoice","question":"Según el manual, ¿qué es un comando \"incorporado\" (builtin)?","options":[{"text":"Un comando implementado internamente por el propio shell, en lugar de por un programa ejecutable.","is_correct":true,"feedback":"Correcto. Esta es la definición precisa de un comando incorporado."},{"text":"Un comando que se encuentra en el directorio /bin.","is_correct":false,"feedback":"Incorrecto. Los comandos en /bin son ejecutables externos, no incorporados."},{"text":"Un comando que requiere privilegios de root para ejecutarse.","is_correct":false,"feedback":"Incorrecto. Los privilegios no definen si un comando es incorporado."},{"text":"Un comando que solo se puede usar en modo interactivo.","is_correct":false,"feedback":"Incorrecto. Muchos incorporados se usan en scripts no interactivos."}],"correct_answer":true,"feedback_correct":"¡Correcto! Los comandos incorporados son parte integral del shell.","feedback_incorrect":"Incorrecto. Revisa la sección de Definiciones para comprender qué es un comando incorporado."},{"type":"multichoice","question":"¿Cuál es el rango máximo de valores para el estado de salida de un comando?","options":[{"text":"0 a 255.","is_correct":true,"feedback":"Correcto. El estado de salida está restringido a ocho bits."},{"text":"0 a 100.","is_correct":false,"feedback":"Incorrecto. El rango es mayor."},{"text":"0 a 1024.","is_correct":false,"feedback":"Incorrecto. El rango es más pequeño."},{"text":"Ilimitado.","is_correct":false,"feedback":"Incorrecto. El estado de salida está limitado a un rango de valores."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has recordado el rango de los estados de salida.","feedback_incorrect":"Incorrecto. Consulta la sección de Definiciones sobre el estado de salida."},{"type":"multichoice","question":"¿Cuál es el propósito principal del entrecomillado en Bash?","options":[{"text":"Eliminar el significado especial de ciertos caracteres o palabras para el shell.","is_correct":true,"feedback":"Correcto. El entrecomillado se utiliza para tratar caracteres y palabras literalmente."},{"text":"Definir variables de entorno.","is_correct":false,"feedback":"Incorrecto. La definición de variables se realiza con asignaciones, no entrecomillado."},{"text":"Ejecutar comandos en segundo plano.","is_correct":false,"feedback":"Incorrecto. Eso se logra con el operador '&'."},{"text":"Optimizar el rendimiento del script.","is_correct":false,"feedback":"Incorrecto. El entrecomillado es para el análisis sintáctico, no para el rendimiento."}],"correct_answer":true,"feedback_correct":"¡Así es! El entrecomillado es fundamental para controlar cómo el shell interpreta los caracteres.","feedback_incorrect":"Incorrecto. Revisa la sección 'Entrecomillado' para entender su propósito."},{"type":"multichoice","question":"¿Cuál es la función del carácter de escape '\\' en Bash, con una excepción clave?","options":[{"text":"Preserva el valor literal del siguiente carácter, excepto con una nueva línea donde se trata como continuación de línea.","is_correct":true,"feedback":"Correcto. La barra invertida escapa el siguiente carácter, pero '\\nueva_línea' es una continuación de línea."},{"text":"Siempre ignora el siguiente carácter.","is_correct":false,"feedback":"Incorrecto. No lo ignora, sino que lo interpreta literalmente."},{"text":"Siempre convierte el siguiente carácter a mayúsculas.","is_correct":false,"feedback":"Incorrecto. Esa no es su función."},{"text":"Se usa para finalizar un comando.","is_correct":false,"feedback":"Incorrecto. Los comandos se finalizan con nueva línea, punto y coma, o operadores de control."}],"correct_answer":true,"feedback_correct":"¡Perfecto! Has identificado la función del carácter de escape y su excepción.","feedback_incorrect":"Incorrecto. Repasa la subsección 'Carácter de Escape'."},{"type":"multichoice","question":"¿Cómo se diferencia un comando simple de un comando más complejo en Bash?","options":[{"text":"Un comando simple consiste en el comando seguido de argumentos, mientras que los complejos combinan comandos simples en tuberías, bucles o construcciones condicionales.","is_correct":true,"feedback":"Correcto. Esta es la distinción fundamental en la sintaxis de comandos de Bash."},{"text":"Un comando simple siempre es un \"builtin\", mientras que los complejos son programas externos.","is_correct":false,"feedback":"Incorrecto. Los comandos simples pueden ser externos y los complejos pueden usar builtins."},{"text":"Un comando simple no puede tener redirecciones, mientras que un comando complejo sí.","is_correct":false,"feedback":"Incorrecto. Ambos pueden tener redirecciones."},{"text":"Los comandos simples usan paréntesis y los complejos usan llaves.","is_correct":false,"feedback":"Incorrecto. Esa es una distinción de agrupamiento, no de complejidad general del comando."}],"correct_answer":true,"feedback_correct":"¡Muy bien! Has comprendido la estructura básica de los comandos en Bash.","feedback_incorrect":"Incorrecto. Revisa la sección 'Comandos del Shell' para entender la diferencia."},{"type":"multichoice","question":"Si la opción `pipefail` está deshabilitada, ¿cuál es el estado de salida de una tubería en Bash?","options":[{"text":"El estado de salida del último comando de la tubería.","is_correct":true,"feedback":"Correcto. Este es el comportamiento predeterminado cuando `pipefail` está deshabilitada."},{"text":"El estado de salida del primer comando de la tubería.","is_correct":false,"feedback":"Incorrecto. El estado de salida no se toma del primer comando."},{"text":"Cero, indicando éxito, independientemente de los comandos intermedios.","is_correct":false,"feedback":"Incorrecto. Solo si todos los comandos exitosos."},{"text":"El valor del último comando que salió con un estado distinto de cero.","is_correct":false,"feedback":"Incorrecto. Esto ocurre cuando `pipefail` *está* habilitada."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has recordado el comportamiento predeterminado del estado de salida de las tuberías.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Tuberías' y la opción `pipefail`."},{"type":"multichoice","question":"¿Qué sucede cuando un comando termina con el operador de control '&'?","options":[{"text":"El shell ejecuta el comando asíncronamente en un subshell, y el shell no espera a que termine.","is_correct":true,"feedback":"Correcto. Esto se conoce como ejecutar el comando en segundo plano."},{"text":"El shell espera a que el comando termine, y luego ejecuta el siguiente comando.","is_correct":false,"feedback":"Incorrecto. Eso es lo que ocurre con el operador ';'."},{"text":"El comando se ejecuta en primer plano con prioridad alta.","is_correct":false,"feedback":"Incorrecto. El operador '&' lo envía a segundo plano."},{"text":"Se produce un error de sintaxis si el control de trabajos no está activo.","is_correct":false,"feedback":"Incorrecto. El comando se ejecuta asíncronamente incluso sin control de trabajos activo."}],"correct_answer":true,"feedback_correct":"¡Así es! El operador '&' es clave para la ejecución asíncrona.","feedback_incorrect":"Incorrecto. Revisa la sección 'Listas de Comandos' y el operador '&'."},{"type":"multichoice","question":"¿Qué forma alternativa del comando `for` es similar al lenguaje C?","options":[{"text":"`for (( expr1 ; expr2 ; expr3 )) [;] do commands ; done`","is_correct":true,"feedback":"Correcto. Esta sintaxis es la forma C-style del bucle `for` en Bash."},{"text":"`for nombre [ [in palabras ...] ; ] do comandos; done`","is_correct":false,"feedback":"Incorrecto. Esta es la forma tradicional del bucle `for`."},{"text":"`for (expr1; expr2; expr3) { commands }`","is_correct":false,"feedback":"Incorrecto. Esta sintaxis no es válida en Bash para un bucle `for`."},{"text":"`loop expr1 expr2 expr3 do commands endloop`","is_correct":false,"feedback":"Incorrecto. Esto no es una sintaxis válida de Bash."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has identificado la sintaxis del bucle `for` estilo C.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Constructores de Bucle' para las formas del comando `for`."},{"type":"multichoice","question":"¿Qué opción de shell, si está habilitada, permite que la coincidencia de patrones en un comando `case` ignore las mayúsculas/minúsculas?","options":[{"text":"`nocasematch`","is_correct":true,"feedback":"Correcto. La opción `nocasematch` habilita la coincidencia insensible a mayúsculas/minúsculas."},{"text":"`extglob`","is_correct":false,"feedback":"Incorrecto. `extglob` habilita patrones extendidos, pero no afecta la sensibilidad a mayúsculas/minúsculas."},{"text":"`dotglob`","is_correct":false,"feedback":"Incorrecto. `dotglob` afecta la coincidencia de nombres de archivo que comienzan con un punto."},{"text":"`globstar`","is_correct":false,"feedback":"Incorrecto. `globstar` habilita el patrón '**' para coincidir con directorios y subdirectorios."}],"correct_answer":true,"feedback_correct":"¡Perfecto! `nocasematch` es la clave para la flexibilidad en la coincidencia de patrones.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Constructores Condicionales' para las opciones de `case`."},{"type":"multichoice","question":"¿En qué contexto se ejecutan las funciones del shell?","options":[{"text":"Se ejecutan en el contexto actual del shell; no se crea un nuevo proceso para interpretarlas.","is_correct":true,"feedback":"Correcto. Esta es una diferencia importante entre funciones y scripts de shell."},{"text":"Siempre se ejecutan en un subshell separado.","is_correct":false,"feedback":"Incorrecto. Los subshells se crean para sustituciones de comandos o agrupamientos con paréntesis, no para funciones normales."},{"text":"Se ejecutan en un nuevo proceso si no son \"builtin\".","is_correct":false,"feedback":"Incorrecto. La ejecución en el contexto actual es la característica distintiva."},{"text":"Se ejecutan solo si están marcadas para exportación.","is_correct":false,"feedback":"Incorrecto. Las funciones pueden exportarse, pero no es una condición para su ejecución."}],"correct_answer":true,"feedback_correct":"¡Exacto! Las funciones del shell comparten el entorno con su llamador.","feedback_incorrect":"Incorrecto. Revisa la sección 'Funciones del Shell' para entender su entorno de ejecución."},{"type":"multichoice","question":"¿Qué atributo se puede asignar a una variable para convertirla en una referencia a otra variable, permitiendo la manipulación indirecta?","options":[{"text":"`nameref` (usando `declare -n`).","is_correct":true,"feedback":"Correcto. El atributo `nameref` crea una referencia a otra variable."},{"text":"`readonly`","is_correct":false,"feedback":"Incorrecto. `readonly` impide la modificación de una variable."},{"text":"`export`","is_correct":false,"feedback":"Incorrecto. `export` marca una variable para ser pasada a procesos hijos."},{"text":"`integer`","is_correct":false,"feedback":"Incorrecto. `integer` fuerza la evaluación aritmética de una variable."}],"correct_answer":true,"feedback_correct":"¡Excelente! Las namerefs son una poderosa característica para la manipulación indirecta de variables.","feedback_incorrect":"Incorrecto. Revisa la sección 'Parámetros del Shell' para conocer los atributos de las variables."},{"type":"multichoice","question":"¿Cuál es el orden correcto en que Bash realiza las siguientes expansiones?\n\n1. Expansión de llaves\n2. División de palabras\n3. Expansión de tilde, expansión de parámetros y variables, sustitución de comandos, expansión aritmética\n4. Eliminación de comillas\n5. Expansión de nombres de archivo","options":[{"text":"1, 3, 2, 5, 4","is_correct":true,"feedback":"Correcto. Este es el orden de las expansiones en Bash."},{"text":"3, 1, 2, 5, 4","is_correct":false,"feedback":"Incorrecto. La expansión de llaves ocurre primero."},{"text":"1, 2, 3, 4, 5","is_correct":false,"feedback":"Incorrecto. El orden de las fases es diferente."},{"text":"4, 1, 3, 2, 5","is_correct":false,"feedback":"Incorrecto. La eliminación de comillas es la última."}],"correct_answer":true,"feedback_correct":"¡Así es! Conocer el orden de las expansiones es crucial para entender el comportamiento del shell.","feedback_incorrect":"Incorrecto. Consulta la sección 'Expansiones del Shell' para el orden correcto de las expansiones."},{"type":"multichoice","question":"¿Cuál sería la salida del comando `echo a{d,c,b}e` en Bash?","options":[{"text":"`ade ace abe`","is_correct":true,"feedback":"Correcto. La expansión de llaves genera una cadena para cada elemento entre las llaves."},{"text":"`a{d,c,b}e`","is_correct":false,"feedback":"Incorrecto. La expansión de llaves se realiza."},{"text":"`adcebe`","is_correct":false,"feedback":"Incorrecto. Los elementos no se concatenan de esta manera."},{"text":"`a d c b e`","is_correct":false,"feedback":"Incorrecto. El prefijo y el sufijo se aplican a cada elemento."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has demostrado tu conocimiento de la expansión de llaves.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Expansión de Llaves' y su comportamiento."},{"type":"multichoice","question":"¿A qué se expande el carácter de tilde `~` cuando aparece solo como prefijo de tilde sin entrecomillar?","options":[{"text":"El valor de la variable de shell `HOME`.","is_correct":true,"feedback":"Correcto. `~` es una abreviatura para el directorio de inicio del usuario."},{"text":"El directorio de trabajo actual (`PWD`).","is_correct":false,"feedback":"Incorrecto. `~+` se expande a `PWD`."},{"text":"El directorio de trabajo anterior (`OLDPWD`).","is_correct":false,"feedback":"Incorrecto. `~-` se expande a `OLDPWD`."},{"text":"El directorio raíz del sistema (`/`).","is_correct":false,"feedback":"Incorrecto. No se expande al directorio raíz."}],"correct_answer":true,"feedback_correct":"¡Así es! La expansión de tilde es una característica conveniente para acceder al directorio HOME.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Expansión de Tilde' para comprender cómo se expande `~`."},{"type":"multichoice","question":"¿Qué hace la expansión de parámetro `${parámetro:-palabra}` si `parámetro` no está establecido o es nulo?","options":[{"text":"Sustituye la expansión de `palabra`.","is_correct":true,"feedback":"Correcto. Este operador proporciona un valor predeterminado si el parámetro está vacío o no establecido."},{"text":"Asigna la expansión de `palabra` a `parámetro`.","is_correct":false,"feedback":"Incorrecto. Eso lo haría el operador `${parámetro:=palabra}`."},{"text":"Escribe un mensaje de error y sale si no es interactivo.","is_correct":false,"feedback":"Incorrecto. Eso lo haría el operador `${parámetro:?palabra}`."},{"text":"No sustituye nada.","is_correct":false,"feedback":"Incorrecto. Eso lo haría el operador `${parámetro:+palabra}` si el parámetro NO está establecido o es nulo."}],"correct_answer":true,"feedback_correct":"¡Correcto! Este es un operador útil para proporcionar valores predeterminados.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Expansión de Parámetros del Shell' y los operadores de expansión de subcadenas."},{"type":"multichoice","question":"¿Cuál es la forma estándar de sustitución de comandos en Bash?","options":[{"text":"`$(comando)`","is_correct":true,"feedback":"Correcto. Esta es la forma moderna y recomendada de sustitución de comandos."},{"text":"`[comando]`","is_correct":false,"feedback":"Incorrecto. Los corchetes son para pruebas condicionales o expresiones aritméticas."},{"text":"`{{comando}}`","is_correct":false,"feedback":"Incorrecto. Esto no es una sintaxis válida para sustitución de comandos."},{"text":"`<comando>`","is_correct":false,"feedback":"Incorrecto. Esto se usa para sustitución de procesos o redirección de entrada."}],"correct_answer":true,"feedback_correct":"¡Excelente! Has reconocido la sintaxis estándar para la sustitución de comandos.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Sustitución de Comandos'."},{"type":"multichoice","question":"Para los propósitos del shell, ¿qué significa que un comando salga con un estado de salida cero?","options":[{"text":"Ha tenido éxito.","is_correct":true,"feedback":"Correcto. Un estado de salida de cero indica éxito en la filosofía Unix."},{"text":"Ha fallado.","is_correct":false,"feedback":"Incorrecto. Un estado distinto de cero indica fallo."},{"text":"Se ha ejecutado asíncronamente.","is_correct":false,"feedback":"Incorrecto. Esto no está directamente relacionado con el estado de salida."},{"text":"Se ha suspendido.","is_correct":false,"feedback":"Incorrecto. Un comando suspendido no ha salido todavía."}],"correct_answer":true,"feedback_correct":"¡Así es! Este es un concepto fundamental en la programación de scripts de shell.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Estado de Salida'."},{"type":"multichoice","question":"Si no se encuentra un comando, ¿qué estado de salida devuelve el proceso hijo creado para ejecutarlo?","options":[{"text":"127.","is_correct":true,"feedback":"Correcto. El estado 127 es estándar para 'comando no encontrado'."},{"text":"0.","is_correct":false,"feedback":"Incorrecto. 0 indica éxito."},{"text":"126.","is_correct":false,"feedback":"Incorrecto. 126 indica que el comando fue encontrado pero no es ejecutable."},{"text":"255.","is_correct":false,"feedback":"Incorrecto. Aunque es un valor máximo, no es el estándar para esta situación."}],"correct_answer":true,"feedback_correct":"¡Excelente! Conocer los códigos de salida es útil para depurar scripts.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Estado de Salida'."},{"type":"multichoice","question":"¿Por qué son necesarios los comandos incorporados (builtins) en el shell?","options":[{"text":"Implementan funcionalidades imposibles o inconvenientes de obtener con utilidades separadas.","is_correct":true,"feedback":"Correcto. Algunos comandos (como `cd`) manipulan directamente el shell, lo que solo pueden hacer los builtins."},{"text":"Son más rápidos que los comandos externos.","is_correct":false,"feedback":"Incorrecto. Aunque a menudo son más rápidos, su necesidad principal no es la velocidad, sino la funcionalidad."},{"text":"Permiten interactuar directamente con el hardware del sistema.","is_correct":false,"feedback":"Incorrecto. Esa es una función de los controladores de dispositivos o syscalls, no de los builtins del shell."},{"text":"Se utilizan para cargar nuevos módulos del kernel.","is_correct":false,"feedback":"Incorrecto. La carga de módulos del kernel es una función de bajo nivel del sistema operativo."}],"correct_answer":true,"feedback_correct":"¡Exacto! Los builtins son esenciales para funcionalidades que requieren acceso directo al estado del shell.","feedback_incorrect":"Incorrecto. Revisa la sección 'Comandos Incorporados del Shell' para entender su propósito."},{"type":"multichoice","question":"¿Qué hace la opción `-P` del comando `cd`?","options":[{"text":"No sigue enlaces simbólicos; los resuelve mientras `cd` atraviesa el directorio.","is_correct":true,"feedback":"Correcto. `-P` obliga a `cd` a usar la ruta física, resolviendo los enlaces simbólicos."},{"text":"Imprime la ruta lógica del directorio actual.","is_correct":false,"feedback":"Incorrecto. Eso es el comportamiento por defecto de `cd` sin `-P` o con `-L`."},{"text":"Permite cambiar a directorios remotos.","is_correct":false,"feedback":"Incorrecto. `cd` es para directorios locales."},{"text":"Crea un nuevo enlace simbólico al directorio de destino.","is_correct":false,"feedback":"Incorrecto. `cd` cambia de directorio, no crea enlaces."}],"correct_answer":true,"feedback_correct":"¡Muy bien! Has comprendido cómo `cd -P` maneja los enlaces simbólicos.","feedback_incorrect":"Incorrecto. Revisa la subsección 'Comandos Incorporados de Bourne Shell' para el comando `cd`."},{"type":"multichoice","question":"¿Qué comportamiento habilita la opción `set -e` en Bash?","options":[{"text":"Sale inmediatamente si una tubería, lista o comando compuesto devuelve un estado distinto de cero.","is_correct":true,"feedback":"Correcto. `set -e` o `set -o errexit` causa que el shell salga al primer comando fallido."},{"text":"Deshabilita la expansión de nombres de archivo.","is_correct":false,"feedback":"Incorrecto. Eso lo hace `set -f`."},{"text":"Habilita la expansión de historial estilo '!'.","is_correct":false,"feedback":"Incorrecto. Eso lo hace `set -H`."},{"text":"Activa el modo privilegiado para el shell.","is_correct":false,"feedback":"Incorrecto. Eso lo hace `set -p`."}],"correct_answer":true,"feedback_correct":"¡Exacto! `set -e` es una opción crucial para el manejo de errores en scripts.","feedback_incorrect":"Incorrecto. Revisa la subsección 'El Comando Incorporado Set' y la opción `-e`."},{"type":"multichoice","question":"¿Qué comportamiento controla la opción `autocd` del comando `shopt`?","options":[{"text":"Si un nombre de comando es un directorio, se ejecuta como si fuera el argumento del comando `cd`.","is_correct":true,"feedback":"Correcto. Si `autocd` está habilitada, escribir solo un nombre de directorio lo convierte en un `cd` implícito."},{"text":"Permite la corrección ortográfica en nombres de directorio.","is_correct":false,"feedback":"Incorrecto. Eso lo controla `dirspell`."},{"text":"Habilita la expansión de llaves.","is_correct":false,"feedback":"Incorrecto. La expansión de llaves está controlada por `braceexpand` y está habilitada por defecto."},{"text":"Hace que los comandos de varias líneas se guarden en una sola entrada del historial.","is_correct":false,"feedback":"Incorrecto. Eso lo controla `cmdhist`."}],"correct_answer":true,"feedback_correct":"¡Excelente! `autocd` simplifica la navegación entre directorios.","feedback_incorrect":"Incorrecto. Revisa la subsección 'El Comando Incorporado Shopt' para la opción `autocd`."}]}}